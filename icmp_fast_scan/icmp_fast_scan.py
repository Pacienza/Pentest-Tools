import random  # gera numeros aleatorios
import socket  # comunicação de rede
import time  # manipula o tempo
import ipaddress  # manipula o endereço ip
import struct  # empacota/desempacota binarios
from threading import Thread  # utiliza threads

SIGNAL = True  # Controla a execução da escuta


# Calcula o checksum do pacote ICMP, que é necessário para garantir a integridade dos dados transmitidos
def checksum(source_string):
    sum = 0
    count_to = (len(source_string) / 2) * 2
    count = 0
    while count < count_to:
        this_val = source_string[count + 1] * 256 + source_string[count]
        sum = sum + this_val
        sum = sum & 0xffffffff
        count = count + 2
    if count_to < len(source_string):
        sum = sum + source_string[len(source_string) - 1]
        sum = sum & 0xffffffff
    sum = (sum >> 16) + (sum & 0xffff)
    sum = sum + (sum >> 16)
    answer = ~sum
    answer = answer & 0xffff
    answer = answer >> 8 | (answer << 8 & 0xff00)
    return answer


"""
A função create_packet cria um pacote ICMP com um header e um payload de dados:

- 8 representa o tipo de mensagem ICMP (echo request).
- id é um identificador único para o pacote.
- data é um payload de dados de 192 caracteres.
"""


# Função pra criar um pacote ICMP
def create_packet(id):
    # Cabeçalho do Pacote ICMP: tipo, código, checksum, id, sequência
    header = struct.pack('bbHHh', 8, 0, 0, id, 1)
    data = 192 * 'Q'  # Payload de dados
    my_checksum = checksum(header + data.encode())  # Calcula o checksum
    header = struct.pack('bbHHh', 8, 0, socket.htons(my_checksum), id, 1)
    return header + data.encode()


"""
A função ping envia um pacote ICMP para um endereço IP:

- Cria um socket raw.
- Gera um ID de pacote único.
- Cria o pacote usando create_packet.
- Conecta ao endereço IP e envia o pacote.
"""


# Função pra enviar um pacote ICMP para um endereço IP
def ping(addr, timeout=1):
    try:
        my_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
        packet_id = int((id(timeout) * random.random()) % 65535)
        packet = create_packet(packet_id)
        my_socket.connect((addr, 80))
        my_socket.sendall(packet)
        my_socket.close()
    except PermissionError:
        pass
    except Exception as e:
        print(e)


"""
A função rotate coordena o envio de pacotes ICMP para uma lista de endereços IP e escreve as respostas em um arquivo:

- Envia pacotes ICMP para todos os endereços IP na rede especificada.
- Aguarda respostas e registra os endereços IP que responderam.
- Desativa o sinal de escuta (SIGNAL).
- Escreve os endereços IP que responderam em um arquivo.
"""


# Função q envia pacotes ICMP para uma lista de endereços IP
def rotate(addr, file_name, wait, responses):
    print("Enviando pacotes", time.strftime("%X %x %Z"))
    for ip in addr:
        ping(str(ip))
        time.sleep(wait)  # Tempo de espera entre upload de pacotes
    print("Todos pacotes enviados", time.strftime("%X %x %Z"))

    print("Esperando todas respostas")
    time.sleep(2)

    # Parar a escuta
    global SIGNAL
    SIGNAL = False
    ping('127.0.0.1')  # Ping final pra acionar o falso em listen

    print(len(responses), "hosts encontrados!")
    print("Escrevendo arquivo")
    hosts = []
    for response in sorted(responses):
        ip = struct.unpack('BBBB', response)
        ip = "{}.{}.{}.{}".format(ip[0], ip[1], ip[2], ip[3])
        hosts.append(ip)
    file = open(file_name, 'w')
    file.write(str(hosts))

    print("Feito!", time.strftime("%X %x %Z"))


# Função para escutar respostas ICMP
def listen(responses, ip_network):
    global SIGNAL
    s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
    s.bind(('', 1))
    print("Escutando")
    while SIGNAL:
        packet = s.recv(1024)[:20][-8:-4]
        if packet not in responses and ipaddress.ip_address(packet) in ip_network:
            responses.append(packet)
    print("Parando a escuta")
    s.close()


if __name__ == "__main__":
    responses = []

    ips = '153.152.10.0/24'  # Rede IP a ser escaneada

    wait = 0.0001  # Tempo de espera entre os pacotes
    file_name = 'log1.txt'  # Nome do arquivo de log

    ip_network = ipaddress.ip_network(ips, strict=False)  # Cria a rede IP

    # Inicia a thread para escutar respostas ICMP
    t_server = Thread(target=listen, args=[responses, ip_network])
    t_server.start()

    # Inicia a thread para enviar pacotes ICMP
    t_ping = Thread(target=rotate, args=[ip_network, file_name, wait, responses])
    t_ping.start()
